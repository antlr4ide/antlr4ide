
/*
* generated by Xtext
*/
lexer grammar InternalAntlr4Lexer;


@header {
package {{package}};

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import {{lexer}};
}

@members {
  public Boolean isLexerRule = null;

  public boolean isToken(int ch) {
    return Character.isUpperCase(ch);
  }
}



Default_hack_ : 'default_hack_';

Fragment : 'fragment';

Finally : 'finally';

Grammar : 'grammar';

Returns : 'returns';

Import : 'import';

Locals : 'locals';

Parser : 'parser';

Throws : 'throws';

Catch : 'catch';

Lexer : 'lexer';

Mode : 'mode';

Tree : 'tree';

PlusSignEqualsSign : '+=';

FullStopFullStop : '..';

ColonColon : '::';

NumberSign : '#';

LeftParenthesis : '(';

RightParenthesis : ')';

Asterisk : '*';

PlusSign : '+';

Comma : ',';

FullStop : '.';

Semicolon : ';' {isLexerRule=null;};

LessThanSign : '<';

EqualsSign : '=';

GreaterThanSign : '>';

QuestionMark : '?';

CommercialAt : '@';

VerticalLine : '|';

RightCurlyBracket : '}';

Tilde : '~';



RULE_TOKEN_VOCAB : 'tokenVocab';

RULE_COLON : ':';

RULE_RARROW : '->';

RULE_OPTIONS_SPEC : 'options' RULE_WSNLCHARS* '{';

RULE_TOKENS_SPEC : 'tokens' RULE_WSNLCHARS* '{';

RULE_RULE_REF : 'a'..'z' RULE_NAME_CHAR* {isLexerRule=false;};

RULE_TOKEN_REF : 'A'..'Z' RULE_NAME_CHAR* {isLexerRule=true;};

fragment RULE_NAME_CHAR : (RULE_NAME_START_CHAR|'0'..'9'|'_'|'\u00B7'|'\u0300'..'\u036F'|'\u203F'..'\u2040');

fragment RULE_NAME_START_CHAR : ('A'..'Z'|'a'..'z'|'\u00C0'..'\u00D6'|'\u00D8'..'\u00F6'|'\u00F8'..'\u02FF'|'\u0370'..'\u037D'|'\u037F'..'\u1FFF'|'\u200C'..'\u200D'|'\u2070'..'\u218F'|'\u2C00'..'\u2FEF'|'\u3001'..'\uD7FF'|'\uF900'..'\uFDCF'|'\uFDF0'..'\uFFFD');

RULE_INT : ('0'..'9')+;

RULE_STRING : '\'' RULE_LITERAL_CHAR* '\'';

fragment RULE_LITERAL_CHAR : (RULE_ESC|~(('\''|'\\')));

fragment RULE_ESC : '\\' ('n'|'r'|'t'|'b'|'f'|'"'|'\''|'\\'|'>'|'u' RULE_XDIGIT RULE_XDIGIT RULE_XDIGIT RULE_XDIGIT|.);

fragment RULE_XDIGIT : ('0'..'9'|'a'..'f'|'A'..'F');

RULE_ACTION : RULE_NESTED_ACTION ('?' ((RULE_WSNLCHARS* '=>') => RULE_WSNLCHARS* '=>')?)?;

fragment RULE_NESTED_ACTION : '{' ( options {greedy=false; k=2;}: RULE_NESTED_ACTION | RULE_SL_COMMENT | RULE_ML_COMMENT | RULE_ACTION_STRING_LITERAL | RULE_ACTION_CHAR_LITERAL | . )* '}' ;

fragment RULE_ACTION_STRING_LITERAL : '"' (('\\')=>RULE_ACTION_ESC | ~'"')* '"';

fragment RULE_ACTION_CHAR_LITERAL : '\'' (('\\')=>RULE_ACTION_ESC | ~'\'' )* '\'';

fragment RULE_ACTION_ESC : '\\' .;

RULE_ARG_OR_CHARSET : ({isLexerRule==Boolean.TRUE}?=>RULE_LEXER_CHAR_SET|{isLexerRule==Boolean.FALSE}?=> RULE_ARG_ACTION);

fragment RULE_LEXER_CHAR_SET : '[' ('\\' ~(('\r'|'\n'))|~(('\r'|'\n'|'\\'|']')))* ']';

fragment RULE_ARG_ACTION : '[' (RULE_ARG_ACTION|('"')=>RULE_ACTION_STRING_LITERAL|('\'')=>RULE_ACTION_CHAR_LITERAL|~(('['|']')))* ']';

RULE_SL_COMMENT : '//' ~(('\r'|'\n'))* '\r'? '\n'?;

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_WS : (' '|'\t'|'\f'|'\r'? '\n')+;

fragment RULE_WSNLCHARS : (' '|'\t'|'\f'|'\n'|'\r');
